<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />

        <title>reveal.js</title>

        <link rel="stylesheet" href="dist/reset.css" />
        <link rel="stylesheet" href="dist/reveal.css" />
        <link rel="stylesheet" href="dist/theme/black.css" />

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section
                    data-markdown
                    data-background-image="bg_1600x900-06.jpg"
                >
                    <script type="text/template">
                        ---
                        <!-- .slide: data-background-image="bg_1600x900-10.jpg" -->
                        **Emmanuel Pinault**

                        ## From Experiment to Production
                        ### The Elixir Tooling Journey

                        4 Layers, One Ecosystem, Endless Possibilities
                        ---
                        ## About Me

                        - **@epinault** on GitHub
                        - Elixir since 2017
                        - **Podium** - 4+ years, 80+ Elixir services in production, 5+ OSS projects
                        - **OSS Maintainer** - Hammer, Geocoder, BEAM community projects

                        ---

                        ## The Bold Claim

                        ### Your typical day involves:

                        - ğŸ **Python** for data exploration (or AI these days)
                        - ğŸ’» **Bash/HCL** for deployment scripts
                        - ğŸ¦€ **Go/Rust** for performance-critical services
                        - ğŸŸ¨ **JavaScript** for web frontends/applications

                        ### Each with different syntax, tooling, and mental models

                        **Elixir can handle all of these contexts**

                        ---

                        ## Python/Ruby

                        ### Great for simple scripts
                        - âœ… **Quick to write**
                        - âœ… **Readable syntax**

                        ### But struggles with...
                        - âŒ **Concurrency is painful** (GIL limitations)
                        - âŒ **Dependency hell** for team sharing
                        - âŒ **No type safety** - Silent failures from type mismatches

                        ---

                        ## JavaScript/Node.js

                        ### Great for web-familiar teams
                        - âœ… **Fast prototyping**
                        - âœ… **JSON handling**

                        ### But struggles with...
                        - âŒ **Callback complexity** for concurrent tasks
                        - âŒ **Limited system integration**
                        - âŒ **Fragile ecosystem** (left-pad incident, dependency bloat)

                        ---

                        ## Go/Rust for Scripts

                        ### Great for performance
                        - âœ… **Excellent concurrency**
                        - âœ… **Great performance**

                        ### But struggles with...
                        - âŒ **Slow development cycle** (compile, test, iterate)
                        - âŒ **Not ideal for quick scripts**
                        - âŒ **Verbose for simple tasks**

                        ---

                        ## Bash/Shell for Scripts

                        ### Great for system tasks
                        - âœ… **System integration**
                        - âœ… **Ubiquitous**

                        ### But struggles with...
                        - âŒ **No data structures**
                        - âŒ **Error handling nightmare**
                        - âŒ **Complex scripts are hard to maintain and read**
                        - âŒ **Platform compatibility issues**

                        ---

                        ## The Result

                        ### Multiple tools = Multiple problems
                        - ğŸ”„ **Context switching** between languages
                        - ğŸ“š **Different ecosystems** to learn and maintain
                        - ğŸ”§ **No single solution** that handles all use cases well
                        - âš¡ **Slow iteration** when you need the "wrong" tool

                        **What if there was a better way?**

                        ---

                        ## The Elixir Way

                        - ğŸ¯ Coherent ecosystem
                        - ğŸ”„ Natural progression
                        - ğŸ“ˆ Gradual complexity
                        - âš¡ Fast feedback loops

                        ---

                        ## The Journey

                        ### ğŸ”¬ Livebook â†’ âš¡ Scripts â†’ ğŸ—ï¸ Simple App â†’ ğŸŒ Phoenix

                        ---

                        <div class="container">
                        <div class="col">

                        ### ğŸ”¬ **Livebook**
                        Explore & Prototype

                        ### âš¡ **Scripts**
                        Automate & Share

                        </div>
                        <div class="col">

                        ### ğŸ—ï¸ **Simple App**
                        Structure & Scale

                        ### ğŸŒ **Phoenix**
                        Deploy & Serve

                        </div>
                        </div>

                        ---

                        # Layer 1: Livebook

                        ---

                        ## Livebook

                        ### Traditional Use Cases
                        - ğŸ““ Interactive development
                        - ğŸ§ª Data exploration
                        - ğŸ“Š Quick visualizations

                        ---

                        ## Livebook Beyond Prototyping

                        ### Production Use Cases
                        - ğŸ“‹ **Production Runbooks** - Incident response
                        - ğŸ“ˆ **Metric Reporting** - Migration health checks
                        - ğŸ” **Data Quality Analysis** - Data quality dashboards
                        - ğŸŒ **API Testing** - "Postman-like" testing without GUI

                        ---

                        # Live Demo

                        *Livebook operational insights*

                        ---

                        ## Livebook Perfect for

                        - ğŸš€ **Zero setup friction** - Browser-based, immediate value
                        - ğŸ¤ **Operations collaboration** - Non-technical teams execute procedures
                        - ğŸ“ **Living runbooks** - Executable operational documentation
                        - ğŸ’¡ **Data exploration** - Interactive analysis and visualization
                        - ğŸ” **System health** - analysis and monitoring
                        - ğŸ“‹ **Production runbooks and incident response**
                        - ğŸ“Š **Migration health checks and reporting**

                        ---

                        # Layer 2: Scripts

                        ---

                        <div style="text-align: center;">
                        <img src="./herrington.png" alt="Herrington" />
                        </div>

                        ---

                        ### Common Developer Pain Points:

                        - ğŸ”„ **Repetitive tasks** across multiple repositories
                        - ğŸ—ï¸ **CI/CD pipeline complexity** with multiple languages/tools
                        - ğŸ› ï¸ **One-off automation** that's too small for full applications
                        - ğŸ“Š **Domain-specific tooling** that doesn't exist elsewhere

                        ---

                        ## Elixir Scripts Excel At:

                        - âš¡ **Fast feedback loops** - Write, test, run immediately
                        - ğŸ§° **Rich standard library** - HTTP, JSON, etc built-in
                        - ğŸ“¦ **Zero dependencies** - Self-contained automation
                        - ğŸ”€ **Cross-platform** - Works anywhere Elixir runs
                        - ğŸš€ **Effortless concurrency** - Handle thousands of parallel tasks naturally (Async Task, Flow, etc.)

                        ---

                        # Live Demo

                        ## From Pain Point to Automation in 5 Minutes

                        ---

                        ## 2025 Distribution Options

                        | Tool | Best For | Requires Erlang? | File Size |
                        |------|----------|------------------|-----------|
                        | **Plain** | No distribution | âœ… Yes | Small |
                        | **Escript** | Team sharing | âœ… Yes | Small |
                        | **Bakeware** | Self-contained | âŒ No | Medium |
                        | **Burrito** | True standalone | âŒ No | Large |

                        ### When to use each:
                        - **Plain/escript** - Quick team utilities, CI/CD scripts
                        - **Burrito** - Complete independence

                        ---

                        ## Scripts Perfect for

                        - ğŸ—ï¸ **CI/CD pipelines** - Deploy, test, build automation across repos
                        - ğŸ”„ **Daily development tasks** - Config sync, dependency updates, code generation
                        - ğŸ§° **Domain-specific tooling** - Migration checkers, API clients, custom validators
                        - ğŸ“¦ **Team productivity** - Shared utilities that eliminate repetitive work

                        ---

                        ### Unique Advantages:

                        - âš¡ **No framework overhead** - Pure Elixir, immediate execution
                        - ğŸ¯ **Exact solution fit** - Build precisely what your team needs
                        - ğŸ”€ **Multi-repo orchestration** - Handle complex workflows across services

                        ---

                        # Layer 3: Simple App

                        ## Structured Development & Background Jobs

                        ---

                        ### Key Features & Use Cases:

                        - **Long-running processes** - Stays alive, handles state
                        - **Background processing** - Reliable job queues with Oban, Task.async, Flow, etc.
                        - **Full Application lifecycle** - Supervision trees, fault tolerance
                        - **Database integration with Ecto** - Persistent data storage

                        ---

                        ### Key Features & Use Cases (continued)

                        - **Configuration management** - Environment-based config
                        - **Comprehensive testing** - Unit, integration, property tests
                        - **Embedded systems** - Hardware integration, embedded devices (Nerves)

                        ---

                        ### Perfect For:

                        - ğŸ“ **Scalable architecture** - Proper separation of concerns
                        - ğŸ§ª **Testable components** - Each module tested in isolation
                        - ğŸ”§ **Reusable modules** - Share logic across applications

                        ---

                        # Live Demo

                        ## A simple agent system with a background job in minutes

                        ---

                        # Layer 4: Full Applications & Real-time Features

                        ---

                        ### What Phoenix Adds & Performance:

                        **Core Features:**
                        - **Web interface** - HTTP endpoints, routing, controllers
                        - **Real-time features** - LiveView, WebSockets, Channels
                        - **User authentication** - Built-in auth, sessions, CSRF protection
                        - **Asset pipeline** - CSS/JS compilation, optimization
                        - **API capabilities** - REST/GraphQL endpoints, JSON APIs
                        - **Deployment tooling** - Releases, clustering, monitoring

                        ---

                        ### What Phoenix Adds & Performance (continued)

                        **Real-world Results:**
                        - ğŸš€ **"Half the time, half the people"** - Internal app development
                        - ğŸ“ˆ **Millions of WebSocket connections** on a single server
                        - ğŸ›¡ï¸ **Fault-isolated components** keep apps running
                        - âš¡ **1-2 minutes** to implement new features after setup

                        ---

                        ## The Complete Journey

                        ### Our Operation Review Agent Evolution:
                        - ğŸ”¬ **Livebook:** Interactive prototype + operational exploration
                        - âš¡ **Script:** CLI automation for scheduled reviews
                        - ğŸ—ï¸ **Simple App:** Background jobs + proper testing
                        - ğŸŒ **Phoenix:** Real-time dashboard for operations team

                        **One core concept, four different contexts**

                        ---

                        ## When to Use Each Layer

                        | Layer | Simplicity | Dev Speed | Cost | Complexity |
                        |-------|------------|-----------|------|------------|
                        | **ğŸ”¬ Livebook** | Very High | Minutes | Very Low | Very Low |
                        | **âš¡ Scripts** | High | Minutes/hours | Low | Low |
                        | **ğŸ—ï¸ Simple App** | Medium | Days | Medium | Medium |
                        | **ğŸŒ Phoenix** | Low | Weeks | High | High |

                        **Choose based on your current need, not your final destination**

                        ---

                        ## Performance Comparison

                        ### When Performance Matters:
                        - **Livebook:** Great for exploration, not production loads
                        - **Scripts:** Excellent for batch processing
                        - **Simple App/Phoenix App:** Optimal for background jobs and APIs

                        **Rule of thumb:** Start with simplicity, optimize when needed

                        ---

                        ## Team Adoption

                        ### Introducing These Patterns:
                        1. Start with Livebook for team knowledge sharing
                        2. Automate common tasks with scripts
                        3. Extract reusable logic into libraries (opinionated ones)
                        4. Build user-facing features in Phoenix

                        ---

                        ## Your Next Steps

                        ### Start Where You Are:
                        - ğŸ’¡ **Got an idea?** â†’ Fire up Livebook, start exploring
                        - ğŸ”§ **Need automation?** â†’ Write a script, solve the immediate problem
                        - ğŸ—ï¸ **Building a service?** â†’ Structure it as a library from day one
                        - ğŸ‘¥ **Want users?** â†’ Phoenix + LiveView for modern web apps

                        **Remember: Evolution over revolution**

                        ---

                        ## Thank You!

                        ### Resources:
                        - ğŸ”— **Demo Repository:** github.com/epinault/elixir-tooling-journey
                        - ğŸ“Š **Slides:** Available at the repo above
                        - ğŸ“š [Code Generation in Action](https://www.manning.com/books/code-generation-in-action)

                        ### Connect:
                        - ğŸ¦ **GitHub:** @epinault
                        - ğŸ’¼ **LinkedIn:** Emmanuel Pinault

                        ---

                        ## Questions?

                        ---
                    </script>
                </section>
            </div>
        </div>

        <style>
            .container {
                display: flex;
                justify-content: space-around;
                align-items: flex-start;
            }

            .col {
                flex: 1;
                margin: 0 10px;
            }

            .reveal pre code {
                font-size: 0.55em;
                line-height: 1.2;
            }

            .reveal table {
                font-size: 0.8em;
            }

            .reveal h1,
            .reveal h2,
            .reveal h3 {
                text-transform: none;
            }

            .reveal .slides section {
                text-align: left;
            }

            .reveal .slides section[data-background*="title"] {
                text-align: center;
            }

            .reveal ul,
            .reveal ol {
                margin-left: 1em;
            }
        </style>
        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,
                progress: true,
                controls: true,
                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
            });
        </script>
    </body>
</html>
